# fb-cpp Contribution Plan

**Date**: February 11, 2026  
**Goal**: Contribute missing features to [fb-cpp](https://github.com/asfernandes/fb-cpp) needed by the Firebird ODBC Driver  
**Last Updated**: February 11, 2026

> This plan prioritizes features the Firebird ODBC Driver needs. Each phase is a standalone PR to fb-cpp.

---

## Overview

| Phase | Feature | Priority | Blocks ODBC Adoption? | Est. Size | Status |
|-------|---------|----------|-----------------------|-----------|--------|
| **1** | Batch Execution (`IBatch` wrapper) | **Critical** | Yes — array parameter binding | ~500 LOC + ~300 LOC tests | ❌ |
| **2** | Scrollable Cursor Control | High | Partially — scrollable cursors work but forward-only isn't default | ~20 LOC | ❌ |
| **3** | Error Vector in `DatabaseException` | **Critical** | Yes — SQLSTATE mapping | ~50 LOC + ~50 LOC tests | ❌ |
| **4** | Move Assignment for Statement & Attachment | Medium | No — workaround with `unique_ptr` | ~30 LOC + ~30 LOC tests | ❌ |
| **5** | Descriptor `alias` Field | Medium | No — can use `getOutputMetadata()->getAlias()` directly | ~10 LOC | ❌ |
| **6** | Thread Safety Documentation | Low | No | Docs only | ❌ |
| **7** | ODBC-Style Usage Example | Low | No | Docs only | ❌ |

**Execution order**: Phase 3 → Phase 1 → Phase 2 → Phase 4 → Phase 5 → Phase 6 → Phase 7

Phase 3 is first because it's the smallest critical item and validates our PR workflow with the maintainer.

---

## Phase 1: Batch Execution (`IBatch` Wrapper)

### Background

The Firebird 4.0+ `IBatch` interface enables bulk DML operations (INSERT/UPDATE/DELETE) with a single server roundtrip. This maps directly to ODBC's "Array of Parameter Values" feature (`SQL_ATTR_PARAMSET_SIZE` > 1) and is the **biggest performance differentiator** for ETL workloads.

The existing ODBC driver already uses `IBatch` directly against the raw Firebird API (Phase 9), but for the fb-cpp migration to work, we need an fb-cpp wrapper.

### Firebird API Surface

From `FirebirdInterface.idl`:

```
interface Batch : ReferenceCounted {
    void add(Status, uint count, const void* inBuffer);
    void addBlob(Status, uint length, const void* inBuffer, ISC_QUAD* blobId, uint parLength, const uchar* par);
    void appendBlobData(Status, uint length, const void* inBuffer);
    void addBlobStream(Status, uint length, const void* inBuffer);
    void registerBlob(Status, const ISC_QUAD* existingBlob, ISC_QUAD* blobId);
    BatchCompletionState execute(Status, Transaction);
    void cancel(Status);
    uint getBlobAlignment(Status);
    MessageMetadata getMetadata(Status);
    void setDefaultBpb(Status, uint parLength, const uchar* par);
    void close(Status);
    void getInfo(Status, uint itemsLength, const uchar* items, uint bufferLength, uchar* buffer);
}

interface BatchCompletionState : Disposable {
    const int EXECUTE_FAILED = -1;
    const int SUCCESS_NO_INFO = -2;
    const uint NO_MORE_ERRORS = 0xFFFFFFFF;

    uint getSize(Status);
    int getState(Status, uint pos);
    uint findError(Status, uint pos);
    void getStatus(Status, Status to, uint pos);
}
```

Creation paths:
- `IStatement::createBatch(Status, MessageMetadata inMetadata, uint parLength, const uchar* par)` — from a prepared statement
- `IAttachment::createBatch(Status, Transaction, uint stmtLength, string sqlStmt, uint dialect, MessageMetadata, uint parLength, const uchar* par)` — from SQL text

### fb-cpp API Design

#### New Files

- `src/fb-cpp/Batch.h` — `BatchOptions`, `BlobPolicy`, `BatchCompletionState`, `Batch` classes
- `src/fb-cpp/Batch.cpp` — Implementation
- `src/test/Batch.cpp` — Tests

#### `BlobPolicy` Enum

```cpp
enum class BlobPolicy : unsigned
{
    NONE = 0,        // IBatch::BLOB_NONE — blobs not allowed
    ID_ENGINE = 1,   // IBatch::BLOB_ID_ENGINE — IDs generated by Firebird
    ID_USER = 2,     // IBatch::BLOB_ID_USER — IDs generated by caller
    STREAM = 3       // IBatch::BLOB_STREAM — inline stream mode
};
```

#### `BatchOptions` Class

```cpp
class BatchOptions final
{
public:
    bool getMultiError() const;
    BatchOptions& setMultiError(bool value);        // TAG_MULTIERROR

    bool getRecordCounts() const;
    BatchOptions& setRecordCounts(bool value);      // TAG_RECORD_COUNTS

    std::optional<unsigned> getBufferBytesSize() const;
    BatchOptions& setBufferBytesSize(unsigned value); // TAG_BUFFER_BYTES_SIZE (max 256MB)

    BlobPolicy getBlobPolicy() const;
    BatchOptions& setBlobPolicy(BlobPolicy value);  // TAG_BLOB_POLICY

    unsigned getDetailedErrors() const;
    BatchOptions& setDetailedErrors(unsigned value); // TAG_DETAILED_ERRORS (default 64)

private:
    bool multiError_ = false;
    bool recordCounts_ = false;
    std::optional<unsigned> bufferBytesSize_;
    BlobPolicy blobPolicy_ = BlobPolicy::NONE;
    unsigned detailedErrors_ = 64;
};
```

The `BatchOptions` class builds the parameters block internally using `IXpbBuilder` (kind `IXpbBuilder::BATCH`). Expose a `buildParametersBlock()` method for internal use.

#### `BatchCompletionState` Class

```cpp
class BatchCompletionState final
{
public:
    // Constants matching IBatchCompletionState
    static constexpr int EXECUTE_FAILED = -1;
    static constexpr int SUCCESS_NO_INFO = -2;

    // Move-only RAII wrapper
    explicit BatchCompletionState(FbRef<fb::IBatchCompletionState> handle) noexcept;
    ~BatchCompletionState() noexcept;
    BatchCompletionState(BatchCompletionState&& o) noexcept;
    BatchCompletionState& operator=(BatchCompletionState&& o) noexcept;
    BatchCompletionState(const BatchCompletionState&) = delete;
    BatchCompletionState& operator=(const BatchCompletionState&) = delete;

    /// Number of messages processed.
    unsigned getSize() const;

    /// Per-message result: affected rows count, EXECUTE_FAILED, or SUCCESS_NO_INFO.
    int getState(unsigned pos) const;

    /// Find next error at or after `pos`. Returns nullopt when no more errors.
    std::optional<unsigned> findError(unsigned pos) const;

    /// Get detailed error status for a specific position.
    /// Returns a vector of intptr_t codes (same format as IStatus::getErrors()).
    std::vector<std::intptr_t> getErrorStatus(Client& client, unsigned pos) const;

private:
    FbRef<fb::IBatchCompletionState> handle_;
};
```

Design notes:
- `findError()` returns `std::optional<unsigned>` instead of raw `0xFFFFFFFF` sentinel — modern C++ style
- `getErrorStatus()` deep-copies the error vector from a temporary IStatus, matching the pattern we propose for `DatabaseException`
- `BatchCompletionState` is Disposable (not ReferenceCounted), so destructor calls `dispose()`

#### `Batch` Class

```cpp
class Batch final
{
public:
    /// Create from a prepared Statement.
    /// The Statement must remain valid for the lifetime of the Batch.
    explicit Batch(Statement& statement, Transaction& transaction,
                   const BatchOptions& options = {});

    /// Create from an Attachment + SQL text (prepare + batch in one call).
    explicit Batch(Attachment& attachment, Transaction& transaction,
                   std::string_view sql, unsigned dialect = 3,
                   const BatchOptions& options = {});

    // Move-only RAII
    Batch(Batch&& o) noexcept;
    Batch& operator=(Batch&&) = delete;   // consistent with current Statement pattern
    Batch(const Batch&) = delete;
    Batch& operator=(const Batch&) = delete;
    ~Batch() noexcept;

    /// Returns whether the batch handle is valid.
    bool isValid() const noexcept;

    //
    // --- Adding messages ---
    //

    /// Add one or more raw messages to the batch buffer.
    /// `inBuffer` must contain `count` aligned messages matching the input metadata.
    void add(unsigned count, const void* inBuffer);

    /// Add the Statement's current input message buffer as one message.
    /// Requires the Statement-based constructor.
    /// Typical usage: stmt.setInt32(0, val); batch.addMessage();
    void addMessage();

    //
    // --- Blob support ---
    //

    /// Add an inline blob and get back its batch-local ID.
    /// Only valid when BlobPolicy is ID_ENGINE or ID_USER.
    BlobId addBlob(std::span<const std::byte> data,
                   const BlobOptions& bpb = {});

    /// Append more data to the last blob added with addBlob().
    void appendBlobData(std::span<const std::byte> data);

    /// Add blob data in stream mode (BlobPolicy::STREAM only).
    void addBlobStream(std::span<const std::byte> data);

    /// Register an existing blob (created via normal Blob class) for use in batch.
    BlobId registerBlob(const BlobId& existingBlob);

    /// Set default BPB for blobs in this batch.
    void setDefaultBpb(const BlobOptions& bpb);

    /// Get the blob alignment requirement.
    unsigned getBlobAlignment();

    //
    // --- Execution ---
    //

    /// Execute all queued messages and return completion state.
    BatchCompletionState execute();

    /// Cancel the batch (discard queued messages).
    void cancel();

    /// Close and release the batch handle.
    void close();

    /// Get the input metadata for this batch.
    FbRef<fb::IMessageMetadata> getMetadata();

    /// Query batch information.
    void getInfo(std::span<const std::uint8_t> items,
                 std::span<std::uint8_t> buffer);

private:
    std::vector<std::uint8_t> buildPbp(const BatchOptions& options);

private:
    Attachment& attachment_;
    Transaction& transaction_;
    Statement* statement_ = nullptr;   // null when created from Attachment+SQL
    FbUniquePtr<fb::IStatus> status_;
    impl::StatusWrapper statusWrapper_;
    FbRef<fb::IBatch> handle_;
};
```

Design notes:
- `addMessage()` is the convenience method that reads from `Statement::inMessage` — it calls `add(1, statement_->inMessage.data())`. This lets users use the type-safe `stmt.setInt32()` / `stmt.setString()` API to build messages.
- `registerBlob()` returns the batch-local `BlobId` (more convenient than the raw out-param API).
- `execute()` takes no parameters — the `Transaction&` was stored at construction time.

### Test Plan

```
BOOST_AUTO_TEST_SUITE(BatchSuite)

// Lifecycle
  constructorFromStatementCreatesBatch
  constructorFromAttachmentCreatesBatch
  moveConstructorTransfersOwnership

// Basic operations
  addAndExecuteReturnsCorrectSize
  addMessageUsesStatementBuffer
  executeWithRecordCountsReportsAffectedRows
  executeReportsNoInfoWhenRecordCountsDisabled

// Error handling
  executeWithBadDataReportsExecuteFailed
  findErrorLocatesFailedMessages
  getErrorStatusReturnsDetailedVector
  multiErrorAllowsPartialSuccess

// Blob support
  addBlobWithIdEngine
  registerExistingBlob
  blobStreamMode

// Edge cases
  cancelDiscardsMessages
  emptyBatchExecuteReturnsZeroSize
  largeBufferHandledCorrectly
```

### Implementation Notes

1. **Parameters block construction**: Use `IXpbBuilder` (kind = `IXpbBuilder::BATCH`) via `IUtil::getXpbBuilder()`. Insert tags for each non-default option. Serialize with `getBuffer()`/`getBufferLength()`.

2. **Message alignment**: `IBatch::add()` requires messages to be aligned to `IMessageMetadata::getAlignment()`. The `addMessage()` convenience method handles this by using the Statement's pre-aligned `inMessage` buffer.

3. **Transaction ownership**: The Batch stores a reference to the Transaction but does NOT own it. The Transaction must remain valid through `execute()`.

4. **Firebird version check**: `IBatch` requires Firebird 4.0+. If the server version is < 4.0, `createBatch()` will throw. We can catch and re-throw with a clearer message, or just let the Firebird error propagate.

---

## Phase 2: Scrollable Cursor Control

### Background

`Statement::execute()` currently always opens cursors with flag `0` (forward-only). The scrollable fetch methods are exposed but require `IStatement::CURSOR_TYPE_SCROLLABLE`. Forward-only is preferred for streaming because the server doesn't buffer the entire result set.

### Changes

#### `StatementOptions` — Add cursor type

```cpp
enum class CursorType
{
    FORWARD_ONLY,
    SCROLLABLE
};

class StatementOptions final
{
public:
    // ... existing members ...

    CursorType getCursorType() const { return cursorType_; }

    StatementOptions& setCursorType(CursorType value)
    {
        cursorType_ = value;
        return *this;
    }

private:
    // ... existing members ...
    CursorType cursorType_ = CursorType::FORWARD_ONLY;
};
```

#### `Statement` — Store and use cursor type

The `StatementOptions` is currently consumed only in the constructor and not stored. Two approaches:

**Option A**: Store `CursorType` as a member of `Statement`, passed from options at constructor time.

**Option B**: Accept `StatementOptions` as a parameter to `execute()`.

**Recommended**: Option A — the cursor type is a property of how you plan to use the statement, decided at prepare time. Store it as `cursorType_` member, used in `execute()`:

```cpp
// In Statement::execute():
case StatementType::SELECT:
case StatementType::SELECT_FOR_UPDATE:
{
    const unsigned flags = (cursorType_ == CursorType::SCROLLABLE)
        ? IStatement::CURSOR_TYPE_SCROLLABLE
        : 0;
    resultSetHandle = statementHandle->openCursor(&statusWrapper, ...flags...);
    break;
}
```

### Test Plan

```
BOOST_AUTO_TEST_SUITE(ScrollableCursorSuite)

  forwardOnlyCursorsRejectFetchPrior        // should throw or return false
  scrollableCursorSupportsFetchAbsolute
  scrollableCursorSupportsFetchRelative
  scrollableCursorSupportsFetchFirst
  scrollableCursorSupportsFetchLast
  scrollableCursorSupportsFetchPrior
  defaultCursorTypeIsForwardOnly
```

---

## Phase 3: Error Vector in `DatabaseException`

### Background

ODBC requires mapping Firebird error codes to SQLSTATE codes. The ODBC driver has a comprehensive mapping table (`OdbcSqlState.h`) with 100+ ISC→SQLSTATE mappings. Currently `DatabaseException` only stores the formatted message string, discarding the raw error vector.

### Changes

#### `DatabaseException` — Store error vector and SQLCODE

```cpp
class DatabaseException final : public FbCppException
{
public:
    using FbCppException::FbCppException;

    explicit DatabaseException(Client& client, const std::intptr_t* status)
        : FbCppException{buildMessage(client, status)},
          errorVector_{copyErrorVector(status)},
          sqlCode_{computeSqlCode(status)}
    {
    }

    /// Returns the raw Firebird error vector (deep copy).
    /// Format: pairs of (isc_arg_type, value) terminated by isc_arg_end.
    const std::vector<std::intptr_t>& getErrors() const noexcept
    {
        return errorVector_;
    }

    /// Returns the legacy SQLCODE computed from the error vector.
    int getSqlCode() const noexcept
    {
        return sqlCode_;
    }

    /// Returns the primary ISC error code (first isc_arg_gds value), or 0 if none.
    std::intptr_t getErrorCode() const noexcept
    {
        // Walk the vector: first pair is (isc_arg_gds, code)
        if (errorVector_.size() >= 2 && errorVector_[0] == isc_arg_gds)
            return errorVector_[1];
        return 0;
    }

private:
    static std::string buildMessage(Client& client, const std::intptr_t* status);

    static std::vector<std::intptr_t> copyErrorVector(const std::intptr_t* status)
    {
        // Walk the status vector to find its length, then copy
        std::vector<std::intptr_t> result;
        const auto* p = status;
        while (*p != isc_arg_end)
        {
            result.push_back(*p++);  // arg type
            result.push_back(*p++);  // arg value
        }
        result.push_back(isc_arg_end);
        return result;
    }

    static int computeSqlCode(const std::intptr_t* status);

    std::vector<std::intptr_t> errorVector_;
    int sqlCode_ = 0;
};
```

#### Implementation Notes

1. **`copyErrorVector()`**: The status vector format is pairs of `(type, value)` terminated by `isc_arg_end`. Type codes: `isc_arg_gds` (1), `isc_arg_string` (2), `isc_arg_cstring` (3), `isc_arg_number` (4), `isc_arg_interpreted` (5), `isc_arg_sql_state` (8). String values point to static or buffer memory — **only numeric types and the type codes are meaningful after the IStatus is reused**. For string args, we should skip copying the pointer (it will dangle). Two options:
   - **Option A**: Copy only `(type, value)` pairs where type is `isc_arg_gds` or `isc_arg_number`. This gives us the ISC error codes we need for SQLSTATE mapping.
   - **Option B**: Deep-copy string arguments into owned memory (more complex but preserves all info).
   
   **Recommendation**: Option A for the initial PR. The ODBC driver only needs `isc_arg_gds` codes for mapping (e.g., `isc_dsql_error`, `isc_deadlock`, `isc_lock_conflict`). String arguments are already captured in `what()`.

2. **`computeSqlCode()`**: Use `isc_sqlcode()` from the fbclient API (available via `Client::getMaster()->getUtilInterface()`), or implement the simple lookup: walk the vector for `isc_arg_gds` codes and map to SQLCODE via the standard table.

3. **`getErrorCode()`**: Convenience — returns the primary ISC error code directly. This is what ODBC drivers most commonly need for the mapping table lookup.

### Test Plan

```
BOOST_AUTO_TEST_SUITE(DatabaseExceptionSuite)

  syntaxErrorHasCorrectErrorCode
  errorVectorContainsIscArgGds
  errorVectorIsTerminatedByIscArgEnd
  sqlCodeIsNonZeroForKnownErrors
  getErrorCodeReturnsFirstGdsCode
  messagePreservedFromBuildMessage
  defaultConstructedHasEmptyVector
```

---

## Phase 4: Move Assignment for Statement & Attachment

### Background

Both `Statement` and `Attachment` have `operator=(T&&) = delete`. This prevents using them in `std::vector`, `std::map`, `std::swap`, etc. The move constructor already exists and works correctly.

### Changes

Add `operator=(Statement&&)` and `operator=(Attachment&&)`:

```cpp
// Statement
Statement& operator=(Statement&& o) noexcept
{
    if (this != &o)
    {
        if (isValid())
        {
            try { free(); } catch (...) {}
        }
        // Move all members (same as move constructor)
        attachment = o.attachment;   // reference, just copy
        status = std::move(o.status);
        statusWrapper = std::move(o.statusWrapper);
        // ... all other members ...
    }
    return *this;
}

// Attachment
Attachment& operator=(Attachment&& o) noexcept
{
    if (this != &o)
    {
        if (isValid())
        {
            try { disconnectOrDrop(false); } catch (...) {}
        }
        client = o.client;  // reference
        handle = std::move(o.handle);
    }
    return *this;
}
```

**Concern**: Both classes hold a `Client&` reference member. References cannot be rebound in C++. Two approaches:
1. Change `Client& client` to `Client* client` — allows rebinding on move. Small API change (`client.foo()` → `client->foo()`).
2. Use `std::reference_wrapper<Client>` — allows rebinding without pointer syntax.

**Recommendation**: Discuss with Adriano. Option 1 (raw pointer) is simplest and most common in move-assignable RAII types.

### Test Plan

```
BOOST_AUTO_TEST_SUITE(MoveAssignmentSuite)

  statementMoveAssignmentTransfersOwnership
  statementMoveAssignmentCleansUpOldHandle
  attachmentMoveAssignmentTransfersOwnership
  attachmentMoveAssignmentCleansUpOldConnection
  swapStatements
```

---

## Phase 5: Descriptor `alias` Field

### Background

ODBC's `SQL_DESC_LABEL` maps to the column alias (e.g., `SELECT foo AS bar` → label is "bar"). The Firebird `IMessageMetadata::getAlias()` provides this, but fb-cpp's `Descriptor` struct only exposes `field` and `relation`, not `alias`.

### Changes

Add `alias` field to `Descriptor`:

```cpp
// In Descriptor.h
struct Descriptor final
{
    // ... existing fields ...

    /// Column alias as reported by IMessageMetadata::getAlias().
    std::string alias;
};
```

Populate in `Statement.cpp` constructor alongside existing `field`/`relation` population:

```cpp
descriptor.alias = outMetadata->getAlias(&statusWrapper, i);
```

### Test Plan

```
BOOST_AUTO_TEST_CASE(descriptorAliasMatchesColumnAlias)
{
    // SELECT 1 AS my_alias FROM rdb$database
    // outDescriptors[0].alias == "MY_ALIAS"
}
```

---

## Phase 6: Thread Safety Documentation

### Changes

Add a "Thread Safety" section to `README.md`:

```markdown
## Thread Safety

- **`Client`**: Thread-safe after construction. Can be shared across threads.
  Do not destroy while other objects reference it.
- **`Attachment`**: The handle itself is thread-safe (Firebird's `IAttachment`
  contract). Each thread should use its own `Transaction` and `Statement`.
- **`Transaction`**: NOT thread-safe. Each thread should have its own instance.
- **`Statement`**: NOT thread-safe. Each thread should have its own instance.
- **`Blob`**: NOT thread-safe. Each thread should have its own instance.
- **`EventListener`**: Thread-safe. Uses internal mutex and condition variable
  for cross-thread notification dispatch.
```

---

## Phase 7: ODBC-Style Usage Example

Deferred until Phases 1 and 3 are merged. Will provide a `examples/odbc_adapter.cpp` showing:

1. Error vector → SQLSTATE mapping
2. Batch insert with per-row error handling  
3. Chunked BLOB read via `Blob::readSegment()` loop
4. Scrollable cursor with `CursorType::SCROLLABLE`
5. Type-safe parameter binding with `Statement::setInt32()` etc.

---

## Dependencies

```
Phase 3 (error vector) ──→ standalone, no deps
Phase 1 (batch) ──→ standalone, no deps
Phase 2 (scrollable) ──→ standalone, no deps
Phase 4 (move assign) ──→ standalone; design discussion needed (reference→pointer)
Phase 5 (alias) ──→ standalone, no deps
Phase 6 (docs) ──→ after Phases 1–5
Phase 7 (example) ──→ after Phases 1, 2, 3
```

All code phases (1–5) are independent and can be submitted as parallel PRs.

---

*Document version: 1.0 — February 11, 2026*
